import Dexie, { type Table } from 'dexie'
import { addDays, isAfter } from 'date-fns'
import type { 
  Contact, 
  Deal, 
  Task, 
  User, 
  OnboardingState,
  DealStage,
  ContactStatus,
  TaskType,
  TaskStatus,
  TaskPriority
} from '@/types'
import { DEAL_STAGES } from '@/types'

export class PipelineZenDB extends Dexie {
  contacts!: Table<Contact>
  deals!: Table<Deal>
  tasks!: Table<Task>
  users!: Table<User>
  onboarding!: Table<OnboardingState>

  constructor() {
    super('PipelineZenDB')
    this.version(1).stores({
      contacts: '++id, name, email, status, score, createdAt, updatedAt',
      deals: '++id, title, contactId, stage, value, createdAt, updatedAt, dueDate, isArchived',
      tasks: '++id, title, contactId, dealId, status, priority, dueDate, createdAt, isAutoGenerated',
      users: '++id, email',
      onboarding: '++id, currentStep, isCompleted'
    })
  }
}

export const db = new PipelineZenDB()

// Utilitaires pour la gestion automatique des délais
export class PipelineManager {
  static async checkAndArchiveExpiredDeals(): Promise<void> {
    const now = new Date()
    const expiredDeals = await db.deals
      .where('isArchived')
      .equals(0)
      .and(deal => {
        const maxDays = DEAL_STAGES[deal.stage].maxDays
        if (maxDays === 0) return false // Les deals "won" et "lost" n'expirent pas
        
        const expirationDate = addDays(deal.createdAt, maxDays)
        return isAfter(now, expirationDate)
      })
      .toArray()

    for (const deal of expiredDeals) {
      // Archiver le deal
      await db.deals.update(deal.id, { 
        isArchived: true,
        updatedAt: now
      })

      // Créer une tâche de relance
      const contact = await db.contacts.get(deal.contactId)
      await db.tasks.add({
        id: crypto.randomUUID(),
        title: `Suivre ${contact?.name || 'contact'} - étape expirée`,
        description: `Deal "${deal.title}" a expiré à l'étape "${DEAL_STAGES[deal.stage].label}"`,
        contactId: deal.contactId,
        dealId: deal.id,
        type: 'follow-up' as TaskType,
        status: 'pending' as TaskStatus,
        priority: 'high' as TaskPriority,
        dueDate: now,
        createdAt: now,
        updatedAt: now,
        isAutoGenerated: true
      })
    }
  }

  static async calculateContactScore(contactId: string): Promise<number> {
    const contact = await db.contacts.get(contactId)
    if (!contact) return 0

    let score = 1 // Score de base

    // +1 pt si réponse e-mail récente (simulé via lastInteraction)
    if (contact.lastInteraction && 
        isAfter(contact.lastInteraction, addDays(new Date(), -7))) {
      score += 1
    }

    // +1 pt si meeting récent (via tâches de type meeting complétées)
    const recentMeetings = await db.tasks
      .where(['contactId', 'type', 'status'])
      .equals([contactId, 'meeting', 'completed'])
      .and(task => isAfter(task.completedAt || task.createdAt, addDays(new Date(), -30)))
      .count()
    
    if (recentMeetings > 0) score += 1

    // +2 pts si devis accepté (deal gagné)
    const wonDeals = await db.deals
      .where(['contactId', 'stage'])
      .equals([contactId, 'won'])
      .count()
    
    score += wonDeals * 2

    // Mettre à jour le score
    await db.contacts.update(contactId, { score, updatedAt: new Date() })
    
    return Math.min(score, 5) // Max 5 étoiles
  }

  static async getPipelineHealth(): Promise<number> {
    const thirtyDaysAgo = addDays(new Date(), -30)
    
    const totalDeals = await db.deals
      .where('createdAt')
      .above(thirtyDaysAgo)
      .count()
    
    const expiredDeals = await db.deals
      .where('createdAt')
      .above(thirtyDaysAgo)
      .and(deal => deal.isArchived)
      .count()

    if (totalDeals === 0) return 100

    const expiredPercentage = (expiredDeals / totalDeals) * 100
    return expiredPercentage > 20 ? 0 : 100 - expiredPercentage
  }
}

// Fonctions utilitaires pour l'initialisation
export async function initializeDefaultUser(): Promise<User> {
  const existingUser = await db.users.orderBy('createdAt').first()
  if (existingUser) return existingUser

  const defaultUser: User = {
    id: crypto.randomUUID(),
    name: 'Utilisateur',
    email: 'user@pipeline-zen.com',
    createdAt: new Date(),
    settings: {
      theme: 'light',
      notifications: true,
      reminderHours: [9, 14, 17],
      pipelineHealthThreshold: 20
    }
  }

  await db.users.add(defaultUser)
  return defaultUser
}

export async function initializeOnboarding(): Promise<OnboardingState> {
  const existingOnboarding = await db.onboarding.orderBy('id').first()
  if (existingOnboarding) return existingOnboarding

  const onboardingState: OnboardingState = {
    currentStep: 0,
    isCompleted: false,
    hasCreatedContact: false,
    hasCreatedDeal: false,
    hasCreatedTask: false
  }

  await db.onboarding.add(onboardingState)
  return onboardingState
}